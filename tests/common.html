<html>
   <head>
      <style> 
      canvas {
        background: black;
      }
      </style>
      <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
      <script type="text/javascript" src="forge/debug.js"></script>
      <script type="text/javascript" src="forge/util.js"></script>
      <script type="text/javascript" src="forge/log.js"></script>
      <script type="text/javascript" src="forge/task.js"></script>
      <script type="text/javascript" src="forge/md5.js"></script>
      <script type="text/javascript" src="forge/sha1.js"></script>
      <script type="text/javascript" src="forge/hmac.js"></script>
      <script type="text/javascript" src="forge/aes.js"></script>
      <script type="text/javascript" src="forge/asn1.js"></script>
      <script type="text/javascript" src="forge/jsbn.js"></script>
      <script type="text/javascript" src="forge/jsbn2.js"></script>
      <script type="text/javascript" src="forge/prng.js"></script>
      <script type="text/javascript" src="forge/random.js"></script>
      <script type="text/javascript" src="forge/pki.js"></script>
      <script type="text/javascript" src="forge/tls.js"></script>
      
      <script type="text/javascript">

      // set forge alias
      var forge = window.forge;

      var canvas_clear = function()
      {
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");
         ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      var random_forge = function()
      {
         do_random(forge.random);
      };

      var test_random_forge = function()
      {
         console.log('XXX', 'ten bytes',
            forge.util.bytesToHex(forge.random.getBytes(10)));
      };

      var do_random = function(inf)
      {
         console.log('painting canvas');
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");
         var imgData = ctx.createImageData(canvas.width, canvas.height);

         // generate random bytes
         var bytes = inf.getBytes(canvas.width * canvas.height * 3);
         var n = 0;
         for(var x = 0; x < imgData.width; x++)
         {
            for(var y = 0; y < imgData.height; y++)
            {
               // index of the pixel in the array
               var idx = (x + y * imgData.width) * 4;

               // set values
               imgData.data[idx + 0] = bytes.charCodeAt(n++); // Red
               imgData.data[idx + 1] = bytes.charCodeAt(n++); // Green
               imgData.data[idx + 2] = bytes.charCodeAt(n++); // Blue
               imgData.data[idx + 3] = 255;        // Alpha
            }
         }

         ctx.putImageData(imgData, 0, 0);
         console.log('done');
      };

      var test_buffer = function()
      {
         ba = forge.util.createBuffer();
         ba.putByte(1);
         ba.putByte(2);
         ba.putByte(3);
         ba.putByte(4);
         ba.putInt32(4);
         ba.putByte(1);
         ba.putByte(2);
         ba.putByte(3);
         ba.putInt32(4294967295);
         var hex = ba.toHex();
         var bytes = [];
         while(ba.length() > 0)
         {
            bytes.push(ba.getByte());
         }
         var expect = [1, 2, 3, 4, 0, 0, 0, 4, 1, 2, 3, 255, 255, 255, 255];
         var exHex = '0102030400000004010203ffffffff';
         console.log('ba', bytes);
         console.log('ex', expect);
         console.log('assert', hex === exHex);

         var buf = forge.util.createBuffer();
         buf.putBytes(forge.util.hexToBytes(exHex));
         console.log('assert', buf.toHex() === exHex);

         // optimized fill
         var count = 200000;
         buf = forge.util.createBuffer();
         var t1 = +new Date();
         buf.fillWithByte('b'.charCodeAt(0), count);
         t1 = +new Date() - t1;

         // slow fill
         bytes = '';
         var t2 = +new Date();
         for(var i = 0; i < count; ++i)
         {
            bytes += 'b';
         }
         t2 = +new Date() - t2;
         console.log('assert', bytes === buf.getBytes());
         console.log('fill times', t1 + ' < ' + t2);

         // optimized xor
         count = 500000;
         var buf1 = forge.util.createBuffer();
         buf1.fillWithByte(0x01, count);
         var buf2 = forge.util.createBuffer();
         buf2.fillWithByte(0x02, count);
         var buf3 = forge.util.createBuffer();
         t1 = +new Date();
         buf3.putBytes(forge.util.xorBytes(
            buf1.getBytes(), buf2.getBytes(), count));
         t1 = +new Date() - t1;
         //console.log('buf3', buf3.toHex());
         
         // slow xor
         buf1 = forge.util.createBuffer();
         buf1.fillWithByte(0x01, count);
         buf2 = forge.util.createBuffer();
         buf2.fillWithByte(0x02, count);
         var buf4 = forge.util.createBuffer();
         t2 = +new Date();
         for(var i = 0; i < count; ++i)
         {
            buf4.putByte(buf1.getByte(i) ^ buf2.getByte(i));
         }
         t2 = +new Date() - t2;
         //console.log('buf4', buf4.toHex());
         console.log('assert', buf4.getBytes() === buf3.getBytes());
         console.log('xor times', t1 + ' < ' + t2); 
      };

      var test_base64 = function()
      {
         var s1 = '00010203050607080A0B0C0D0F1011121415161719';
         var s2 = 'MDAwMTAyMDMwNTA2MDcwODBBMEIwQzBEMEYxMDExMTIxNDE1MTYxNzE5';
         var out = forge.util.encode64(s1);
         console.log('out', out);
         console.log('ex', s2);
         out = forge.util.decode64(s2);
         console.log('out', out);
         console.log('ex', s1);
      };

      var test_base64_speed = function()
      {
         var str, count, st, et;

         str = '';
         for(var i = 0; i < 100; i++)
         {
            str += '00010203050607080A0B0C0D0F1011121415161719';
         }
         count = 5000;
         st = +new Date();
         for(var i = 0; i < count; i++)
         {
            var out = forge.util.encode64(str);
         }
         et = +new Date();
         console.log('time per encode', ((et - st)/count) + ' ms');

         str = '';
         for(var i = 0; i < 100; i++)
         {
            str += 'MDAwMTAyMDMwNTA2MDcwODBBMEIwQzBEMEYxMDExMTIxNDE1MTYxNzE5';
         }
         count = 5000;
         st = +new Date();
         for(var i = 0; i < count; i++)
         {
            var out = forge.util.decode64(str);
         }
         et = +new Date();
         console.log('time per decode', ((et - st)/count) + ' ms');
      };

      var test_md5 = function()
      {
         // empty message sha-1
         var expect = 'd41d8cd98f00b204e9800998ecf8427e';
         var md = forge.md.md5.create();
         console.log('digest', md.digest().toHex());
         console.log('assert', md.digest().toHex() === expect);

         // message md5 ('abc')
         expect = '900150983cd24fb0d6963f7d28e17f72';
         md.start();
         md.update('abc');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);

         // message md5 ('The quick brown fox jumps over the lazy dog')
         expect = '9e107d9d372bb6826bd81d3542a419d6';
         md.start();
         md.update('The quick brown fox jumps over the lazy dog');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message md5 ('THIS IS A MESSAGE')
         expect = '78eebfd9d42958e3f31244f116ab7bbe';
         md.start();
         md.update('THIS IS ');
         md.update('A MESSAGE');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
      };

      var test_md5_long = function()
      {
         var input = forge.util.createBuffer();
         input.putBytes(forge.util.hexToBytes(
            '0100002903018d32e9c6dc423774c4c39a5a1b78f44cc2cab5f676d39' +
            'f703d29bfa27dfeb870000002002f0100'));
         input.putBytes(forge.util.hexToBytes(
            '0200004603014c2c1e835d39da71bc0857eb04c2b50fe90dbb2a8477f' +
            'e7364598d6f0575999c20a6c7248c5174da6d03ac711888f762fc4ed5' +
            '4f7254b32273690de849c843073d002f00'));
         input.putBytes(forge.util.hexToBytes(
            '0b0003d20003cf0003cc308203c8308202b0a003020102020100300d0' +
            '6092a864886f70d0101050500308186310b3009060355040613025553' +
            '311d301b060355040a13144469676974616c2042617a6161722c20496' +
            'e632e31443042060355040b133b4269746d756e6b206c6f63616c686f' +
            '73742d6f6e6c7920436572746966696361746573202d20417574686f7' +
            '2697a6174696f6e207669612042545031123010060355040313096c6f' +
            '63616c686f7374301e170d3130303231343137303931395a170d32303' +
            '03231333137303931395a308186310b3009060355040613025553311d' +
            '301b060355040a13144469676974616c2042617a6161722c20496e632' +
            'e31443042060355040b133b4269746d756e6b206c6f63616c686f7374' +
            '2d6f6e6c7920436572746966696361746573202d20417574686f72697' +
            'a6174696f6e207669612042545031123010060355040313096c6f6361' + 
            '6c686f737430820122300d06092a864886f70d01010105000382010f0' + 
            '03082010a0282010100dc436f17d6909d8a9d6186ea218eb5c86b848b' + 
            'ae02219bd56a71203daf07e81bc19e7e98134136bcb012881864bf03b' +
            '3774652ad5eab85dba411a5114ffeac09babce75f31314345512cd87c' +
            '91318b2e77433270a52185fc16f428c3ca412ad6e9484bc2fb87abb4e' +
            '8fb71bf0f619e31a42340b35967f06c24a741a31c979c0bb8921a90a4' +
            '7025fbeb8adca576979e70a56830c61170c9647c18c0794d68c0df38f' +
            '3aac5fc3b530e016ea5659715339f3f3c209cdee9dbe794b5af92530c' +
            '5754c1d874b78974bfad994e0dfc582275e79feb522f6e4bcc2b2945b' +
            'aedfb0dbdaebb605f9483ff0bea29ecd5f4d6f2769965d1b3e04f8422' +
            '716042680011ff676f0203010001a33f303d300c0603551d130101ff0' +
            '4023000300e0603551d0f0101ff0404030204f0301d0603551d250416' +
            '301406082b0601050507030106082b06010505070302300d06092a864' +
            '886f70d010105050003820101009c4562be3f2d8d8e388085a697f2f1' +
            '06eaeff4992a43f198fe3dcf15c8229cf1043f061a38204f73d86f4fb' +
            '6348048cc5279ed719873aa10e3773d92b629c2c3fcce04012c81ba3b' +
            '4ec451e9644ec5191078402d845e05d02c7b4d974b4588276e5037aba' +
            '7ef26a8bddeb21e10698c82f425e767dc401adf722fa73ab78cfa069b' +
            'd69052d7ca6a75cc9225550e315d71c5f8764362ea4dbc6ecb837a847' +
            '1043c5a7f826a71af145a053090bd4bccca6a2c552841cdb1908a8352' +
            'f49283d2e641acdef667c7543af441a16f8294251e2ac376fa507b53a' +
            'e418dd038cd20cef1e7bfbf5ae03a7c88d93d843abaabbdc5f3431132' + 
            'f3e559d2dd414c3eda38a210b8'));
         input.putBytes(forge.util.hexToBytes('0e000000'));
         input.putBytes(forge.util.hexToBytes(
            '10000102010026a220b7be857402819b78d81080d01a682599bbd0090' +
            '2985cc64edf8e520e4111eb0e1729a14ffa3498ca259cc9ad6fc78fa1' +
            '30d968ebdb78dc0b950c0aa44355f13ba678419185d7e4608fe178ca6' +
            'b2cef33e4193778d1a70fe4d0dfcb110be4bbb4dbaa712177655728f9' +
            '14ab4c0f6c4aef79a46b3d996c82b2ebe9ed1748eb5cace7dc44fb67e' +
            '73f452a047f2ed199b3d50d5db960acf03244dc8efa4fc129faf8b65f' +
            '9e52e62b5544722bd17d2358e817a777618a4265a3db277fc04851a82' +
            'a91fe6cdcb8127f156e0b4a5d1f54ce2742eb70c895f5f8b85f5febe6' +
            '9bc73e891f9280826860a0c2ef94c7935e6215c3c4cd6b0e43e80cca3' +
            '96d913d36be'));

         var md = forge.md.md5.create();
         md.start();
         md.update(input.getBytes());
         var got = 'c0fc3d9ae0b17db9f0aac6ab2063b33a';
         var expect = 'd15a2da0e92c3da55dc573f885b6e653';
         console.log('digest', md.digest().toHex());
         console.log('expect', expect);
         console.log('assert', expect === md.digest().toHex());
      };
      
      var count_md5_speed = 300;
      var test_md5_speed = function()
      {
         // create input data
         var input = ['0123456789abcdef', '', '', '', ''];
         for(var i = 0; i < 4; ++i)
         {
            input[1] += input[0];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[2] += input[1];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[3] += input[2];
         }
         for(var i = 0; i < 8; ++i)
         {
            input[4] += input[3];
         }
         
         var md = forge.md.md5.create();

         console.log('md5 times in 1000s of bytes/sec processed:');

         var st, et;
         var output =
            ['  16 bytes: ',
             '  64 bytes: ',
             ' 256 bytes: ',
             '1024 bytes: ',
             '8192 bytes: '];
         var s = [16, 64, 256, 1024, 8192];
         var t = [0, 0, 0, 0, 0];
         var ct = count_md5_speed;
         var c = [ct, ct, ct, ct, ct];
         for(var n = 0; n < 5; ++n)
         {
            var f = function(n)
            {
               setTimeout(function()
               {
                  for(var i = 0; i < c[n]; ++i)
                  {
                     md.start();
                     st = +new Date();
                     md.update(input[n]);
                     md.digest();
                     et = +new Date();
                     t[n] = t[n] + (et - st);
                  }
                  console.log(output[n], (t[n] / c[n] * s[n]) + 'k/sec');
               }, 0);
            }(n);
         }
      };
      
      var test_sha1 = function()
      {
         // empty message sha-1
         var expect = 'da39a3ee5e6b4b0d3255bfef95601890afd80709';
         var md = forge.md.sha1.create();
         //console.log('digest', md.digest().toHex());
         console.log('assert', md.digest().toHex() === expect);

         // message sha-1 ('abc')
         expect = 'a9993e364706816aba3e25717850c26c9cd0d89d';
         md.start();
         md.update('abc');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message sha-1 ('The quick brown fox jumps over the lazy dog')
         expect = '2fd4e1c67a2d28fced849ee1bb76e7391b93eb12';
         md.start();
         md.update('The quick brown fox jumps over the lazy dog');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message sha-1 ('THIS IS A MESSAGE')
         expect = '5f24f4d6499fd2d44df6c6e94be8b14a796c071d';
         md.start();
         md.update('THIS IS ');
         md.update('A MESSAGE');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
      };

      var count_sha1_speed = 300;
      var test_sha1_speed = function()
      {
         // create input data
         var input = ['0123456789abcdef', '', '', '', ''];
         for(var i = 0; i < 4; ++i)
         {
            input[1] += input[0];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[2] += input[1];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[3] += input[2];
         }
         for(var i = 0; i < 8; ++i)
         {
            input[4] += input[3];
         }
         
         var md = forge.md.sha1.create();

         console.log('sha-1 times in 1000s of bytes/sec processed:');

         var st, et;
         var output =
            ['  16 bytes: ',
             '  64 bytes: ',
             ' 256 bytes: ',
             '1024 bytes: ',
             '8192 bytes: '];
         var s = [16, 64, 256, 1024, 8192];
         var t = [0, 0, 0, 0, 0];
         var ct = count_sha1_speed;
         var c = [ct, ct, ct, ct, ct];
         for(var n = 0; n < 5; ++n)
         {
            var f = function(n)
            {
               setTimeout(function()
               {
                  for(var i = 0; i < c[n]; ++i)
                  {
                     md.start();
                     st = +new Date();
                     md.update(input[n]);
                     md.digest();
                     et = +new Date();
                     t[n] = t[n] + (et - st);
                  }
                  console.log(output[n], (t[n] / c[n] * s[n]) + 'k/sec');
               }, 0);
            }(n);
         }
      };

      var test_hmac = function()
      {
         var expect, key, hmac, mac;
         
         // md5 hmac 16-byte key
         expect = '9294727a3638bb1c13f48ef8158bfc9d';
         key = forge.util.hexToBytes(
            '0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b');
         hmac = forge.hmac.create();
         hmac.start('MD5', key);
         hmac.update('Hi There');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('md5 with 16-byte key', mac.toHex() === expect);

         // md5 hmac short key
         expect = '750c783e6ab0b503eaa86e310a5db738';
         key = 'Jefe';
         hmac = forge.hmac.create();
         hmac.start('MD5', key);
         hmac.update('what do ya want for nothing?');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('md5 with short key', mac.toHex() === expect);

         // md5 hmac long key
         expect = '6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd';
         key = forge.util.hexToBytes(
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa');
         hmac = forge.hmac.create();
         hmac.start('MD5', key);
         hmac.update('Test Using Larger Than Block-Size Key - Hash Key First');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('md5 with 80-byte key', mac.toHex() === expect);

         // sha-1 hmac 20-byte key
         expect = 'b617318655057264e28bc0b6fb378c8ef146be00';
         key = forge.util.hexToBytes(
            '0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b');
         hmac = forge.hmac.create();
         hmac.start('SHA1', key);
         hmac.update('Hi There');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('sha-1 with 20-byte key', mac.toHex() === expect);

         // sha-1 hmac short key
         expect = 'effcdf6ae5eb2fa2d27416d5f184df9c259a7c79';
         key = 'Jefe';
         hmac = forge.hmac.create();
         hmac.start('SHA1', key);
         hmac.update('what do ya want for nothing?');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('sha-1 with short key', mac.toHex() === expect);

         // sha-1 hmac long key
         expect = 'aa4ae5e15272d00e95705637ce8a3b55ed402112';
         key = forge.util.hexToBytes(
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa');
         hmac = forge.hmac.create();
         hmac.start('SHA1', key);
         hmac.update('Test Using Larger Than Block-Size Key - Hash Key First');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('sha-1 with 80-byte key', mac.toHex() === expect);
      };

      var test_oid = function()
      {
         var asn1 = forge.asn1;
         var oid, der, expect;
         
         oid = '1.2.840.113549';
         der = asn1.oidToDer(oid);
         expect = '2a864886f70d';
         //console.log('hex', der.toHex());
         console.log('assert', expect === der.toHex());

         expect = oid;
         oid = asn1.derToOid(der);
         //console.log('oid', oid);
         console.log('assert', expect === oid);
      };

      var sPrivateKey =
      '-----BEGIN RSA PRIVATE KEY-----\r\n' +
      'MIICXQIBAAKBgQDL0EugUiNGMWscLAVM0VoMdhDZEJOqdsUMpx9U0YZI7szokJqQ\r\n' +
      'NIwokiQ6EonNnWSMlIvy46AhnlRYn+ezeTeU7eMGTkP3VF29vXBo+dLq5e+8VyAy\r\n' +
      'Q3FzM1wI4ts4hRACF8w6mqygXQ7i/SDu8/rXqRGtvnM+z0MYDdKo80efzwIDAQAB\r\n' +
      'AoGAIzkGONi5G+JifmXlLJdplom486p3upf4Ce2/7mqfaG9MnkyPSairKD/JXvfh\r\n' +
      'NNWkkN8DKKDKBcVVElPgORYT0qwrWc7ueLBMUCbRXb1ZyfEulimG0R3kjUh7NYau\r\n' +
      'DaIkVgfykXGSQMZx8FoaT6L080zd+0emKDDYRrb+/kgJNJECQQDoUZoiC2K/DWNY\r\n' +
      'h3/ppZ0ane2y4SBmJUHJVMPQ2CEgxsrJTxet668ckNCKaOP/3VFPoWC41f17DvKq\r\n' +
      'noYINNntAkEA4JbZBZBVUrQFhHlrpXT4jzqtO2RlKZzEq8qmFZfEErxOT1WMyyCi\r\n' +
      'lAQ5gUKardo1Kf0omC8Xq/uO9ZYdED55KwJBALs6cJ65UFaq4oLJiQPzLd7yokuE\r\n' +
      'dcj8g71PLBTW6jPxIiMFNA89nz3FU9wIVp+xbMNhSoMMKqIPVPC+m0Rn260CQQDA\r\n' +
      'I83fWK/mZWUjBM33a68KumRiH238v8XyQxj7+C8i6D8G2GXvkigFAehAkb7LZZd+\r\n' +
      'KLuGFyPlWv3fVWHf99KpAkBQFKk3MRMl6IGJZUEFQe4l5whm8LkGU4acSqv9B3xt\r\n' +
      'qROkCrsFrMPqjuuzEmyHoQZ64r2PLJg7FOuyhBnQUOt4\r\n' +
      '-----END RSA PRIVATE KEY-----';

      var sPublicKey =
      '-----BEGIN PUBLIC KEY-----\r\n' +
      'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDL0EugUiNGMWscLAVM0VoMdhDZ\r\n' +
      'EJOqdsUMpx9U0YZI7szokJqQNIwokiQ6EonNnWSMlIvy46AhnlRYn+ezeTeU7eMG\r\n' +
      'TkP3VF29vXBo+dLq5e+8VyAyQ3FzM1wI4ts4hRACF8w6mqygXQ7i/SDu8/rXqRGt\r\n' +
      'vnM+z0MYDdKo80efzwIDAQAB\r\n' +
      '-----END PUBLIC KEY-----';
         
      var sCertPem =
      '-----BEGIN CERTIFICATE-----\r\n' +
      'MIIDIjCCAougAwIBAgIJANE2aHSbwpaRMA0GCSqGSIb3DQEBBQUAMGoxCzAJBgNV\r\n' +
      'BAYTAlVTMREwDwYDVQQIEwhWaXJnaW5pYTETMBEGA1UEBxMKQmxhY2tzYnVyZzEN\r\n' +
      'MAsGA1UEChMEVGVzdDENMAsGA1UECxMEVGVzdDEVMBMGA1UEAxMMbXlzZXJ2ZXIu\r\n' +
      'Y29tMB4XDTEwMDYxOTE3MzYyOFoXDTExMDYxOTE3MzYyOFowajELMAkGA1UEBhMC\r\n' +
      'VVMxETAPBgNVBAgTCFZpcmdpbmlhMRMwEQYDVQQHEwpCbGFja3NidXJnMQ0wCwYD\r\n' +
      'VQQKEwRUZXN0MQ0wCwYDVQQLEwRUZXN0MRUwEwYDVQQDEwxteXNlcnZlci5jb20w\r\n' +
      'gZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMvQS6BSI0YxaxwsBUzRWgx2ENkQ\r\n' +
      'k6p2xQynH1TRhkjuzOiQmpA0jCiSJDoSic2dZIyUi/LjoCGeVFif57N5N5Tt4wZO\r\n' +
      'Q/dUXb29cGj50url77xXIDJDcXMzXAji2ziFEAIXzDqarKBdDuL9IO7z+tepEa2+\r\n' +
      'cz7PQxgN0qjzR5/PAgMBAAGjgc8wgcwwHQYDVR0OBBYEFPV1Y+DHXW6bA/r9sv1y\r\n' +
      'NJ8jAwMAMIGcBgNVHSMEgZQwgZGAFPV1Y+DHXW6bA/r9sv1yNJ8jAwMAoW6kbDBq\r\n' +
      'MQswCQYDVQQGEwJVUzERMA8GA1UECBMIVmlyZ2luaWExEzARBgNVBAcTCkJsYWNr\r\n' +
      'c2J1cmcxDTALBgNVBAoTBFRlc3QxDTALBgNVBAsTBFRlc3QxFTATBgNVBAMTDG15\r\n' +
      'c2VydmVyLmNvbYIJANE2aHSbwpaRMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEF\r\n' +
      'BQADgYEARdH2KOlJWTC1CS2y/PAvg4uiM31PXMC1hqSdJlnLM1MY4hRfuf9VyTeX\r\n' +
      'Y6FdybcyDLSxKn9id+g9229ci9/s9PI+QmD5vXd8yZyScLc2JkYB4GC6+9D1+/+x\r\n' +
      's2hzMxuK6kzZlP+0l9LGcraMQPGRydjCARZZm4Uegln9rh85XFQ=\r\n' +
      '-----END CERTIFICATE-----';

      var test_private_key_from_pem = function()
      {
         try
         {
            var privateKey = forge.pki.privateKeyFromPem(sPrivateKey);
            console.log('privateKey', privateKey);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var test_public_key_from_pem = function()
      {
         try
         {
            var publicKey = forge.pki.publicKeyFromPem(sPublicKey);
            console.log('publicKey', publicKey);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var test_cert_from_pem = function()
      {
         try
         {
            var cert = forge.pki.certificateFromPem(sCertPem);
            console.log('cert', cert);
            console.log('CN', cert.subject.getField('CN').value);
            console.log('C', cert.subject.getField(
               {shortName: 'C'}).value);
            console.log('stateOrProvinceName', cert.subject.getField(
               {name: 'stateOrProvinceName'}).value);
            console.log('2.5.4.7', cert.subject.getField(
               {type: '2.5.4.7'}).value);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var sSignature =
         '9200ece65cdaed36bcc20b94c65af852e4f88f0b4fe5b249d54665f815992ac4' +
         '3a1399e65d938c6a7f16dd39d971a53ca66523209dbbfbcb67afa579dbb0c220' +
         '672813d9e6f4818f29b9becbb29da2032c5e422da97e0c39bfb7a2e7d568615a' +
         '5073af0337ff215a8e1b2332d668691f4fb731440055420c24ac451dd3c913f4';

      var test_verify_signature = function()
      {
         try
         {
            var key = forge.pki.publicKeyFromPem(sPublicKey);
            var md = forge.md.sha1.create();
            md.update('0123456789abcdef');
            var signature = forge.util.hexToBytes(sSignature);
            var success = key.verify(md.digest().getBytes(), signature);
            console.log('assert', success === true);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var test_sign_verify = function()
      {
         try
         {
            var privateKey = forge.pki.privateKeyFromPem(sPrivateKey);
            var publicKey = forge.pki.publicKeyFromPem(sPublicKey);

            // do sign
            var md = forge.md.sha1.create();
            md.update('0123456789abcdef');
            var st = +new Date();
            var signature = privateKey.sign(md);
            var et = +new Date();
            console.log('sign time', (et - st) + 'ms');

            // do verify
            st = +new Date();
            var success = publicKey.verify(md.digest().getBytes(), signature);
            et = +new Date();
            console.log('verify time', (et - st) + 'ms');
            console.log('assert', success === true);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };
      
      var test_cert_verify = function()
      {
         try
         {
            var cert = forge.pki.certificateFromPem(sCertPem, true);
            console.log('cert', cert);
            var success = cert.verify(cert);
            console.log('assert', success === true);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var test_prf_tls1 = function()
      {
         var secret = forge.util.createBuffer();
         for(var i = 0; i < 48; ++i)
         {
            secret.putByte(0xAB);
         }
         secret = secret.getBytes();
         var seed = forge.util.createBuffer();
         for(var i = 0; i < 64; ++i)
         {
            seed.putByte(0xCD);
         }
         seed = seed.getBytes();
         
         var bytes = forge.tls.prf_tls1(secret, 'PRF Testvector',  seed, 104);
         var expect =
            'd3d4d1e349b5d515044666d51de32bab258cb521' +
            'b6b053463e354832fd976754443bcf9a296519bc' +
            '289abcbc1187e4ebd31e602353776c408aafb74c' +
            'bc85eff69255f9788faa184cbb957a9819d84a5d' +
            '7eb006eb459d3ae8de9810454b8b2d8f1afbc655' +
            'a8c9a013';
         //console.log('output', bytes.toHex());
         console.log('assert', expect === bytes.toHex());
      };
      
      // 128-bit test keys
      var aesKeys = [
         '00010203050607080A0B0C0D0F101112',
         '14151617191A1B1C1E1F202123242526',
         '28292A2B2D2E2F30323334353738393A',
         '3C3D3E3F41424344464748494B4C4D4E',
         '50515253555657585A5B5C5D5F606162',
         '64656667696A6B6C6E6F707173747576',
         '78797A7B7D7E7F80828384858788898A',
         '8C8D8E8F91929394969798999B9C9D9E',
         'A0A1A2A3A5A6A7A8AAABACADAFB0B1B2',
         'B4B5B6B7B9BABBBCBEBFC0C1C3C4C5C6',
         'C8C9CACBCDCECFD0D2D3D4D5D7D8D9DA',
         'DCDDDEDFE1E2E3E4E6E7E8E9EBECEDEE',
         'F0F1F2F3F5F6F7F8FAFBFCFDFE010002',
         '04050607090A0B0C0E0F101113141516',
         '2C2D2E2F31323334363738393B3C3D3E',
         '40414243454647484A4B4C4D4F505152',
         '54555657595A5B5C5E5F606163646566',
         '68696A6B6D6E6F70727374757778797A',
         '7C7D7E7F81828384868788898B8C8D8E',
         'A4A5A6A7A9AAABACAEAFB0B1B3B4B5B6'];

      // create aes IV
      var aesIvBytes = forge.random.getBytes(16);
      var aesIvWords = [];
      var aesIv = '';
      for(var i = 0; i < aesIvBytes.length; i++)
      {
         var hex = aesIvBytes.charCodeAt(i).toString(16);
         aesIv += (hex.length == 1) ? ('0' + hex) : hex;
      }
      for(var i = 0; i < aesIvBytes.length; i += 4)
      {
         aesIvWords.push(
            aesIvBytes.charCodeAt(i) << 24 ^
            aesIvBytes.charCodeAt(i + 1) << 16 ^
            aesIvBytes.charCodeAt(i + 2) << 8 ^
            aesIvBytes.charCodeAt(i + 3));
      }
      //console.log('aesIv', aesIv);

      // test data to encrypt
      var aesPlain =
         String.fromCharCode(0x00) +
         String.fromCharCode(0x11) +
         String.fromCharCode(0x22) +
         String.fromCharCode(0x33) +
         String.fromCharCode(0x44) +
         String.fromCharCode(0x55) +
         String.fromCharCode(0x66) +
         String.fromCharCode(0x77) +
         String.fromCharCode(0x88) +
         String.fromCharCode(0x99) +
         String.fromCharCode(0xaa) +
         String.fromCharCode(0xbb) +
         String.fromCharCode(0xcc) +
         String.fromCharCode(0xdd) +
         String.fromCharCode(0xee) +
         String.fromCharCode(0xff);
      var aesPlainWords = [
         0x00112233,
         0x44556677,
         0x8899aabb,
         0xccddeeff];
      var aesPlainBytes = [
         0x00, 0x11, 0x22, 0x33,
         0x44, 0x55, 0x66, 0x77,
         0x88, 0x99, 0xaa, 0xbb,
         0xcc, 0xdd, 0xee, 0xff];

      var aes_test_tables = function()
      {
         console.log('generating AES test tables ...');

         var xtime = new Array(256);
         for(var i = 0; i < 128; i++)
         {
            xtime[i] = i << 1;
            xtime[i + 128] = (i + 128) << 1 ^ 0x11B;
         }
         console.log('first xtime', xtime);   

         // compute xtime table which maps b onto GF(b, 0x02)
         // compute anti-log and log tables
         var xtime = new Array(256);
         var atable = new Array(256);
         var ltable = new Array(256);
         var b = 1, b2;
         for(var i = 0; i < 256; i++)
         {
            atable[i] = b;
            ltable[b] = i;
            b2 = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1 & 0xFF);
            xtime[b] = b2;
            b ^= b2;
         }
         xtime[0] = 0;
         atable[255] = atable[0];
         ltable[0] = 0;

         // compute sbox and isbox
         var sbox = new Array(256);
         var isbox = new Array(256);
         for(var i = 0; i < 256; i++)
         {
            // multiplicative inverse: 0 or atable[255 - ltable[i]]
            b = (i == 0) ? 0 : atable[255 - ltable[i]];

            // SubBytes() affine transformation 
            b = b ^ (b << 1) ^ (b << 2) ^ (b << 3) ^ (b << 4);
            b = (b >> 8) ^ (b & 0xFF) ^ 0x63;
            sbox[i] = b;
            isbox[b] = i;
         }
         
         var inv = [];
         for(var i = 0; i < 256; i++)
         {
            inv[i] = (i == 0) ? 0 : atable[(255 - ltable[i])];
         }
         console.log('inv', inv);

         // inverse: atable[255 - ltable[b]];
         console.log('atable', atable);
         console.log('ltable', ltable);
         console.log('xtime', xtime);

         console.log('xtime(61)=' + xtime[61] + ',gmul=' +
               atable[(ltable[61] + ltable[2])%255]);
         console.log('sbox', sbox);
         console.log('isbox', isbox);
      };

      var word_array_to_string = function(wa)
      {
         // get words from buffer
         if(wa.constructor != Array)
         {
            var bytes = wa.bytes();
            wa = [];
            for(var i = 0; i < bytes.length; i += 4)
            {
               wa.push(
                  bytes.charCodeAt(i) << 24 ^
                  bytes.charCodeAt(i + 1) << 16 ^
                  bytes.charCodeAt(i + 2) << 8 ^
                  bytes.charCodeAt(i + 3));
            }
         }
         
         var str = '[';
         for(var i = 0; i < wa.length; i++)
         {
            // handle signed hex
            if(wa[i] < 0)
            {
               str += (wa[i] + 0xFFFFFFFF + 1).toString(16);
            }
            else
            {
               str += wa[i].toString(16);
            }
            if(i + 1 < wa.length)
            {
               str += ',';
            }
         }
         str += ']';
         return str;
      };

      var aes_forge_128 = function()
      {
         console.log('testing forge AES-128 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         
         var expect = [];
         expect.push(0x69c4e0d8);
         expect.push(0x6a7b0430);
         expect.push(0xd8cdb780);
         expect.push(0x70b4c55a);

         var output = [];
         var w = forge.aes._expandKey(key, false);
         forge.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = forge.aes._expandKey(key, true);
         forge.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_forge_192 = function()
      {
         console.log('testing forge AES-192 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         key.push(0x10111213);
         key.push(0x14151617);
         
         var expect = [];
         expect.push(0xdda97ca4);
         expect.push(0x864cdfe0);
         expect.push(0x6eaf70a0);
         expect.push(0xec0d7191);

         var output = [];
         var w = forge.aes._expandKey(key, false);
         forge.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = forge.aes._expandKey(key, true);
         forge.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_forge_256 = function()
      {
         console.log('testing forge AES-256 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         key.push(0x10111213);
         key.push(0x14151617);
         key.push(0x18191a1b);
         key.push(0x1c1d1e1f);
         
         var expect = [];
         expect.push(0x8ea2b7ca);
         expect.push(0x516745bf);
         expect.push(0xeafc4990);
         expect.push(0x4b496089);

         var output = [];
         var w = forge.aes._expandKey(key, false);
         forge.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = forge.aes._expandKey(key, true);
         forge.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var count_128_speed = 70000;

      var aes_forge_128_speed = function()
      {
         console.log('testing forge AES-128 speed ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = count_128_speed;
         for(var i = 0; i < count; i++)
         {
            var output = [];
            var w = forge.aes._expandKey(key, false);
            now = +new Date();
            forge.aes._updateBlock(w, block, output, false);
            totalEncrypt += (+new Date()) - now;

            block = output;
            output = [];
            w = forge.aes._expandKey(key, true);
            now = +new Date();
            forge.aes._updateBlock(w, block, output, true);
            totalDecrypt += (+new Date()) - now;
         }

         console.log('encrypt time: ' + (totalEncrypt / count) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / count) + ' ms');
         console.log('forge aes-128 speed test complete.');
      };

      var aes_forge = function()
      {
         console.log('testing AES (forge) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = 100;
         var totalTimes = aesKeys.length * count;
         for(var n = 0; n < count; n++)
         {
            for(var i = 0; i < aesKeys.length; i++)
            {
               var k = aesKeys[i];
               var key = [];
               key.push(parseInt(k.substr(0, 8), 16));
               key.push(parseInt(k.substr(8, 8), 16));
               key.push(parseInt(k.substr(16, 8), 16));
               key.push(parseInt(k.substr(24, 8), 16));
               
               var we = forge.aes._expandKey(key, false);
               var wd = forge.aes._expandKey(key, true);
               var block = aesPlainWords;
               var output = [];
               
               // encrypt
               now = +new Date();
               forge.aes._updateBlock(we, block, output, false);
               totalEncrypt += (+new Date()) - now;
               
               // decrypt
               block = output;
               output = [];
               now = +new Date();
               forge.aes._updateBlock(wd, block, output, true);
               totalDecrypt += (+new Date()) - now;
            }
         }
         
         console.log('encrypt time: ' + (totalEncrypt / totalTimes) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / totalTimes) + ' ms');
         console.log('forge aes test complete.');
      };

      var aes_forge_cbc = function()
      {
         console.log('testing AES-CBC (forge) ...');

         var keys = [
            '06a9214036b8a15b512e03d534120006',
            'c286696d887c9aa0611bbb3e2025a45a',
            '6c3ea0477630ce21a2ce334aa746c2cd',
            '56e47a38c5598974bc46903dba290349'
         ];

         var ivs = [
            '3dafba429d9eb430b422da802c9fac41',
            '562e17996d093d28ddb3ba695a2e6f58',
            'c782dc4c098c66cbd9cd27d825682c81',
            '8ce82eefbea0da3c44699ed7db51b7d9'
         ];

         var inputs = [
            'Single block msg',
            '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f',
            'This is a 48-byte message (exactly 3 AES blocks)',
            'a0a1a2a3a4a5a6a7a8a9aaabacadaeaf' +
               'b0b1b2b3b4b5b6b7b8b9babbbcbdbebf' +
               'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf' +
               'd0d1d2d3d4d5d6d7d8d9dadbdcdddedf'
         ];

         var outputs = [
            'e353779c1079aeb82708942dbe77181a',
            'd296cd94c2cccf8a3a863028b5e1dc0a7586602d253cfff91b8266bea6d61ab1',
            'd0a02b3836451753d493665d33f0e886' +
               '2dea54cdb293abc7506939276772f8d5' +
               '021c19216bad525c8579695d83ba2684',
            'c30e32ffedc0774e6aff6af0869f71aa' +
               '0f3af07a9a31a9c684db207eb0ef8e4e' +
               '35907aa632c3ffdf868bb7b29d3d46ad' +
               '83ce9f9a102ee99d49a53e87f4c3da55'
         ];

         for(var i = 0; i < keys.length; ++i)
         {
            var key = forge.util.hexToBytes(keys[i]);
            console.log('key', forge.util.bytesToHex(key));
            var iv = forge.util.hexToBytes(ivs[i]);
            var input = (i & 1) ? forge.util.hexToBytes(inputs[i]) : inputs[i];
            var expect = outputs[i];
            
            console.log('input in hex', forge.util.bytesToHex(input));

            // encrypt w/no padding
            cipher = forge.aes.createEncryptionCipher(key);
            cipher.start(iv);
            cipher.update(forge.util.createBuffer(input));
            cipher.finish(function(){return true;});
            
            console.log('encrypted', cipher.output.toHex());
            console.log('expect', expect);
            console.log('assert', expect === cipher.output.toHex());
            
            // decrypt
            var ct = cipher.output;
            cipher = forge.aes.createDecryptionCipher(key);
            cipher.start(iv);
            cipher.update(ct);
            cipher.finish(function(){return true;});
            
            var out = (i & 1) ? cipher.output.toHex() : cipher.output.bytes();
            console.log('decrypted', out);
            console.log('expect', inputs[i]);
            console.log('assert', inputs[i] === out);
         }
      };

      var aes_forge_cbc_speed = function()
      {
         console.log('testing AES-CBC (forge) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = 2000;
         var totalTimes = aesKeys.length * count;
         for(var n = 0; n < count; n++)
         {
            for(var i = 0; i < aesKeys.length; i++)
            {
               var k = aesKeys[i];
               var key = [];
               key.push(parseInt(k.substr(0, 8), 16));
               key.push(parseInt(k.substr(8, 8), 16));
               key.push(parseInt(k.substr(16, 8), 16));
               key.push(parseInt(k.substr(24, 8), 16));
               
               var input = forge.util.createBuffer(aesPlain);
               
               // encrypt
               cipher = forge.aes.startEncrypting(key, aesIvWords);
               now = +new Date();
               cipher.update(input);
               cipher.finish();
               totalEncrypt += (+new Date()) - now;
               
               // decrypt
               var ct = cipher.output;
               cipher = forge.aes.startDecrypting(key, aesIvWords);
               now = +new Date();
               cipher.update(ct);
               cipher.finish();
               totalDecrypt += (+new Date()) - now;
            }
         }

         console.log('encrypt time: ' + (totalEncrypt / totalTimes) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / totalTimes) + ' ms');
         console.log('forge aes test complete.');
      };
      
      </script>
   </head>
   <body>
      <p>Use the controls below to test forge stuff.</p>
      <div id="random_controls">
         <button id="clear" onclick="javascript:return canvas_clear();">clear</button>
         <button id="random1" onclick="javascript:return random_forge();">forge</button>
         <button id="random3" onclick="javascript:return test_random_forge();">test random</button>
      </div>
      <canvas id="canvas" width="300" height="300"></canvas>
      <div id="util_controls">
         <button id="buffer" onclick="javascript:return test_buffer();">buffer</button>
         <button id="base64" onclick="javascript:return test_base64();">base64</button>
         <button id="base64_speed" onclick="javascript:return test_base64_speed();">base64 speed</button>
      </div>
      <div id="hash_controls">
         <button id="md5" onclick="javascript:return test_md5();">md5</button>
         <button id="md5_long" onclick="javascript:return test_md5_long();">md5 long</button>
         <button id="md5_speed" onclick="javascript:return test_md5_speed();">md5 speed</button>
         <button id="sha1" onclick="javascript:return test_sha1();">sha1</button>
         <button id="sha1_speed" onclick="javascript:return test_sha1_speed();">sha1 speed</button>
         <button id="hmac" onclick="javascript:return test_hmac();">hmac</button>
      </div>
      <div id="pki">
         <button id="oid" onclick="javascript:return test_oid();">asn.1 oid</button>
         <button id="private_key_pem" onclick="javascript:return test_private_key_from_pem();">private key from pem</button>
         <button id="public_key_pem" onclick="javascript:return test_public_key_from_pem();">public key from pem</button>
         <button id="cert_pem" onclick="javascript:return test_cert_from_pem();">cert from pem</button>
         <button id="verify_signature" onclick="javascript:return test_verify_signature();">verify signature</button>
         <button id="sign_verify" onclick="javascript:return test_sign_verify();">sign and verify signature</button>
         <button id="verify_cert" onclick="javascript:return test_cert_verify();">verify cert</button>
      </div>
      <div id="flashTest">
         <p>Could not load the flash Test.</p>
      </div>
      <div id="aes_controls">
         <button id="aes_forge128" onclick="javascript:return aes_forge_128();">forge 128</button>
         <button id="aes_forge192" onclick="javascript:return aes_forge_192();">forge 192</button>
         <button id="aes_forge256" onclick="javascript:return aes_forge_256();">forge 256</button>
         <button id="aes__forge128_speed" onclick="javascript:return aes_forge_128_speed();">forge 128 speed</button>
         <br />
         <button id="aes_forge" onclick="javascript:return aes_forge();">forge</button>
         <button id="aes_forge_cbc" onclick="javascript:return aes_forge_cbc();">forge CBC</button>
         <button id="aes_forge_cbc_speed" onclick="javascript:return aes_forge_cbc_speed();">forge CBC speed</button>
         <button id="aes_flash128" onclick="javascript:return aes_flash_128();">flash 128</button>
         <button id="aes_flash" onclick="javascript:return aes_flash_test();">flash test</button>
         <br />
         <button id="tls_prf" onclick="javascript:return test_prf_tls1();">tls prf</button>
      </div>
   </body>
</html>
